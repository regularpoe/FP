fp

Novice

- Immutable Data                                                - Use second-order functions (map, filter, fold) on immutable data
- Second-Order Functions                                        - Destructure values to access their components
- Constructing & Destructuring                                  - Use data types to represent optionality
- Function Composition                                          - Read basic type signatures
- First-Class Functions & Lambdas                               - Pass lambdas to second-order functions

Advanced beginner

- Algebraic Data Types                                          - Solve problems without nulls, exceptions, or type casts
- Pattern Matching                                              - Process & transform recursive data structures using recursion
- Parametric Polymorphism                                       - Able to use functional programming "in the small"
- General Recursion                                             - Write basic monadic code for a concrete monad
- Type Classes, Instances & Laws                                - Create type class instances for custom data types
- Lower-Order Abstractions (Equal, Semigroup, Monoid, etc)      - Model a business domain with ADTs
- Referential Transparency & Totallity                          - Write functions that take and return functions
- Higher-Order Functions                                        - Reliably identify & isolate pure code from impure code
- Partial-Application, Currying & Point-Free Style              - Avoid introducing unnecessary lambdas & named parameters

Competent

- Generalized Algebraic Data Types                              - Able to use functional programming "in the large"
- Higher-Kinded Types                                           - Test code using generators and properties
- Rank-N Types                                                  - Write imperative code in a purely functional way through monads
- folds & unfolds                                               - Use popular purely functional libraries to solve business problems
- Higher-Order Abstractions (Category, Functor, Monad)          - Separate decision from effects
- Basic Optics                                                  - Write a simple custom lawful monad
- Efficient Persistent Data Structures                          - Write production medium-sized projects
- Existential Types                                             - Use lenses & prisms to manipulate data
- Embedded DSLs using Combinators                               - Simplify types by hiding irrelavant data with existentials

Proficient

- Codata                                                        - Design a minimally-powerful monad transformer stack
- (Co)Recursion Schemes                                         - Write concurrent and streaming programs
- Advanced Optics                                               - Use purely functional mocking in tests
- Dual Abstractions (Comonad)                                   - Use type classes to modularily model different effects
- Monad Transformers                                            - Recognize type patterns & abstract over them
- Free Monads & Extensible Effects                              - Use functional libraries in novel ways
- Functional Architecture                                       - Use optics to manipulate state
- Advanced Functors (Exponential, Profunctors, Contravariant)   - Write custom lawful monad transformers
- Embedded DSLs using GADTs, Finally Tagless                    - Use free monads / extensible effects to separate concerns
- Advanced Monads (Continuation, Logic)                         - Encode invariants at the type level
- Type Famillies, Functional Dependencies                       - Effectively use FDs / type famillies to create safer code

EXPERT

- High-Performance                                              - Design a generic, lawful library with broad appeal
- Kind polymorphism                                             - Prove properties manially using equational reasoning
- Generic Programming                                           - Design & implement a new functiona PL
- Type-Level Programming                                        - Create novel abstractions with laws
- Dependent-Types, Singleton Types                              - Write distributed systems with certain guarantees
- Category Theory                                               - Use proof systems to formally prove properties of code
- Graph Reduction                                               - Create libraries that do not permit invalid states
- Higher-Order Abstract Syntax                                  - Use dependent-typing to prove more properties at compile-time
- Compiler Design for Functional Languages                      - Understand deep relationships between different concepts
- Profunctor Optics                                             - Profile, debug & optimize purely functional code with minimal sacrifices
